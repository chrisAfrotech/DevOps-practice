*************GIT & GITHUB VCS(COURSERA COURSE)************

link to the DEVOPS roadmap: https://roadmap.sh/devops
******************************************************************
            First part :) (On road to master GITHUB)
******************************************************************


A version control system allows us to keep track of when and who did what changes to our files. Those can be code, configuration, images, or whatever else we need to track.

Diffing files:
The diff tool shows all the differences between any type of file. By highlighting what’s changed, it helps us understand the changes and see how the files have been modified.
-eg command:
diff -u old_file new_file > change.diff :  So with this command, we're generating a file called change.diff with the contents of diff-u command. 

What does the patch command do?
It applies the changes contained in a diff file to another file.
-eg command:
patch cpu_usage.py < cpu_usage.diff

While diff is the command that generates the difference between two files, patch is the command that applies those differences to the original file.
So To automatically apply changes to a file, we need to run the patch command on the file that we want to modify with the diff file as input.

Finally diff is used to find differences between two files. On its own, it’s a bit hard to use; instead, use it with diff -u to find lines which differ in two files:
diff -u is used to compare two files, line by line, and have the differing lines compared side-by-side in the same output.
Patch is useful for applying file differences.

****************VCS (version control system)***************
A Version Control System keeps track of the changes that we make to our files.
By keeping track of the changes that we make to our files, a VCS lets us know when a file changed, who changed it, and also lets us easily roll back those changes.
We can use it to store configuration files, documentation, data files, or any other content that we may need to track. Because of the way tools like diff and patch work, a VCS is especially useful when tracking text files, which can be compared with diff and modified with patch. 

  ----VCS and automation
By having each change tracked in the VCS, it's very easy to go back to previous versions when an issue with a change is discovered.
One of the main benefits of a VCS is that you can see the history of how files changed and understand what changed at each step and what motivated the change.

  ----What is GIT:
 Git is a VCS created in 2005 by Linus Torvalds. The developer who started the Linux kernel.
 Git on a single machine without even having a network connection. Or you can use it as a server on a machine where you want to host your repository. And then you can use Git as a client to access the repository from another machine or even the same one.

wHY is git so powerful?
Because each contributor to a Git repo has a full copy of the repository, they can interact with the tracked files without needing a coordinating server. In turn, this improves collaboration.
Because of the way Git was designed, repositories can be useful for any number of developers, from one to thousands.

SCM(source control management) is the other name of Version Control System and there is other kind of vcs as 
  -Subversion
  -mercurial

there more information here about git:
  -https://git-scm.com/doc
  -https://www.mercurial-scm.org/
  -https://subversion.apache.org/
  -https://en.wikipedia.org/wiki/Version_control


--------installing git--------------------
version: git --version
install: apt install git or yarn install git
One interesting thing about the Windows installation is that it comes preloaded with an environment called MinGW64. 
This environment lets us operate on Windows with the same commands and tools available on Linux. 
Running "git --version" in your computer will display the currently installed version of Git (if Git is installed on your computer).


***************First step with git*****************
 Let's start by setting some basic configuration. Remember when we said that a VCS tracks who made which changes, for this to work, we need to tell Git who we are. We can do this by using the Git config command and then setting the values of user.email and user.name to our email and our name.
    eg: git config --global user.email "adEmail5@gmail.com"
        git config --global user.name "myName"

    rq: we use "--global" to specify that is for all the git respository

 when we run "git init" we initialize an empty git repository in the current directory.
    eg: Git innit 

The "ls-la" command which lists files that start with a dot. 

We can also use the "ls-l .git/" command to look inside of it and see the many different things it contains.

So whenever you clone a repository, this git directory is copied to your computer. 
Whenever you run "git init" to create a new repository like we just did, a new git directory is initialized. 
The area outside the git directory is the working tree. The working tree is the current version of your project. 
You can think of it like a workbench or a sandbox where you perform all the modification you want to your file. This working tree will contain all the files that are currently tracked by Git and any new files that we haven't yet added to the list of track files.

-------What are the git directory and the working tree?-----
The git directory acts as a database for all the changes tracked in Git and the working tree acts as a sandbox where we can edit the current versions of the files.

To make Git track our file, we'll add it to the project using the "git add" command passing the file that we want as a parameter. 
    eg: git add "fileName"

With that, we've added our file to the "staging area". 
The "staging area" which is also known as the "index" is a file maintained by Git that contains all of the information about what files and changes are going to go into your next command. 

We can use the git status command to get some information about the current working tree and pending changes. Let's check that one out.
    eg: git status 


We see that our new file is marked to be committed, this means that our change is currently in the staging area. 
To get it committed into the.git directory, we run the git commit command. 
    eg: git commit 

*******************Tracking files***************
Files are suppose to have 3 states when it's tracking:
    -Modified
    -Staged
    -Commited

So, the next step is to stage those changes. When we do this, our modified files become stage files. In other words, the changes to those files are ready to be committed to the project. All files that are staged will be part of the next snapshot we take. And finally, when a file gets committed, the changes made to it are safely stored in a snapshot in the Git directory. 
This means that typically a file tracked by Git, will first be modified when we change it in any way. Then it becomes staged when we mark those changes for tracking. And finally it will get committed when we store those changes in the VCS.

--------What do we need to do after modifying a file tracked by Git?-----
After modifying a file, we need to stage those changes and then commit them afterwards.


***************The basic GIT Workflow****************
 Basic commands:
    -git init: innittialize the git respository
    -git config -l: it'll give all the user configuration of the respository (email, name...)
    -git add: Put your file ready to be tracked by git by move it in the stage status, 
    -git add -p: Allows a user to interactively review patches to add to the current commit
    -git status: it'll tell us the state of the file if it's ready to be stage and wait fot the next message
    -git commit -m "messages": it'll take the stage file and add it to the database which represent here our vcs the git respository
    -"git commit -a -m "messages"":making a small change and want to skip the staging step
    -"git log": command used to display commit messages 
    -"git log -p": It shows added lines with plusses and remove lines with dashes.
    -"git log -p -2": It shows added lines with plusses and remove lines with dashes for the last two commit.
    -"git log --stat":  This will cause git log to show some stats about the changes in the commit, like which files were changed and how many lines were added or removed.
    -"git log 2": it'll show the last 2 commits we did 
    -"git log --graph --oneline": display a summarized view of the commit history for a repo, showing one line per commit
    -git show: Shows various objects
    -"git diff -- staged": to see the changes that are staged but not committed. With this command
    -"git diff" equivalent to the "diff -u" format: shows only unstaged changes by default. Is the extra lines that we've added
    -"git add -p":This way we can detect if there's any changes that we don't want to commit.
    -"git rm 'fileName'":  the file was deleted from the directory, and the change was also staged to be committed in our next commit.
    -"git mv 'fileName' 'newNAmeFile'": The git mv command works in a similar way to the mv command on Linux and so can be used for both moving and renaming.
    -"git checkout": restores files to the latest stored snapshot, reverting any changes before staging.
    --"git checkout 'fileName'":checking out the original file from the latest storage snapshot.
    -"git commit --amend" :git will take whatever is currently in our staging area and run the git commit workflow to overwrite the previous commit.
    -"git revert HEAD": a new commit is created with inverse changes.
    git commit --amend allows us to modify and add changes to the most recent commit.
    -"git revert 8d5a3189b88d273ef08286e5074b5e38d616da21": to revert to the earlier version of code.
    -"git checkout branchName": to switch to another branch
    -"git checkout -b event-better-feature": git create a new branch call "event-better-feature" and switch to it.
    -"git merge branchName": to merge the commit we had done by be on the branch we want to add on
    -"git log --graph --oneline":display a summarized view of the commit history for a repo, showing one line per commit
    -"git merge --abort" : This will stop the merge and reset the files in your working tree back to the previous commit before the merge ever happened.
    -"git clone": clone respository 
    -"git remote -v": to look at the configuration for that remote respository.
    -"git remote show origin": to get even more information about our remote respository
    


"git mv 'fileName' 'newNAmeFile'": The git mv command works in a similar way to the mv command on Linux and so can be used for both moving and renaming.

---When committing new files or changes with git commit, the user is asked to provide a commit message. What will happen if an empty commit message is entered?-----------
    You can’t commit with an empty commit message.


****************Anatomy of a Commit Message*************
So the first line is usually kept to about 
"50 characters or less." 

The line contains a short description of what the commit changes are about. After the first line, comes an empty line, and the rest of the text is usually kept 
"under 72 characters." 
This text is intended to provide a detailed explanation of what's going on with the change. It can reference bugs or issues that will be fixed with the change. It can also include links to more information when relevant. The line limits can be annoying but they help in making the commit message be more digestible for the reader. 

There's a git command used to display these commit messages called "git log". 

Sometimes it can be tempting to just write something short like:
    -update, 
    -change or 
    -fix 
as the description of our commit messages. 

"Don't do it". 

It's super frustrating to go back to repositories history and discover that there's not enough context to understand what was changed and why. It takes only a few more seconds to write a better description. This can be invaluable down the line. Following these guidelines can help make your commit message really useful, and the investment of work now will really pay off later. 
If you're interested in learning more about git commit style, there are plenty of resources out there to read including the Linux kernel documentation itself along with impassioned opinions from other developers.

******************************************************************
                    Second part :)
******************************************************************

*************Advanced git interaction*****************
------------skipping the staging area----------
 Instead, git commit -a is a shortcut to stage any changes to tracked files and commit them in one step.
 If the modified file has never been committed to the repo, we'll still need to use git add to track it first(case of a new respository).

 ------If we're making a small change and want to skip the staging step, which two flags do we need to add to the git commit command?-----
    git commit -a -m "messages"

**************Getting More Information About Our Changes*********
"git log -p": It shows added lines with plusses and remove lines with dashes. Because the amount of text is now longer than what fits on your screen, Git automatically uses a paging tool that allows us to scroll using page up, page down, and the arrow keys. And exit out by pressing "q".

The format is equivalent to the diff-u output command that we saw earlier.
 
"git log --stat":  This will cause git log to show some stats about the changes in the commit, like which files were changed and how many lines were added or removed.

------------If we want to see a specific commit, which command would we use along with the commit ID?------------
Taking the commit ID, git show will show information about the commit and its associated patch.

 "git diff -- staged": to see the changes that are staged but not committed. With this command

 "git diff" equivalent to the "diff -u" format: shows only unstaged changes by default. Is the extra lines that we've added

 "git add -p":This way we can detect if there's any changes that we don't want to commit.

************Deleting and Renaming Files*****************
"git rm 'fileName'":  the file was deleted from the directory, and the change was also staged to be committed in our next commit.

"git mv 'fileName' 'newNAmeFile'": The git mv command works in a similar way to the mv command on Linux and so can be used for both moving and renaming.

NB: After rename , move or delete the file will go in stage state and we have finally to commit changes.

 If there are files that get automatically generated by our scripts, or our operating system generates artifacts that we don't want in our repo, we'll want to ignore them so that they don't add noise to the output of git status. 
 To do this, we can use the "gitignore" file.
    eg: -echo .ds_store > .gitignore //to add the .ds_store to the gitignore file
        -git add .gitignore

NB: HEAD is a symbolic reference pointing to wherever you are in your commit history. It follows you wherever you go, whatever you do, like a shadow. 

******---------*******Undoing things******-----------******
************Undoing Changes Before Committing***********
"git checkout 'fileName'":checking out the original file from the latest storage snapshot. 

-------What is the purpose of the git checkout command?------
"git checkout": restores files to the latest stored snapshot, reverting any changes before staging.

"gir checkout -p":  This will ask you change by change if you want to go back to the previous snapshot or not

"git reset":remove changes from the staging area.

"git reset -p":to get git to ask you which specific changes you want to reset.

********************Amending Commits***************
"git commit --amend" :git will take whatever is currently in our staging area and run the git commit workflow to overwrite the previous commit. 

-------------What does the git commit --amend do?---------
git commit --amend allows us to modify and add changes to the most recent commit. 

NB: But you should avoid amending commits that have already been made public when you are working in team on the same project. 

************************Rollbacks*******************
"One morning before coffee, you make a few changes to one of these scripts and commit the updated files. A few hours later, you start to receive tickets from users indicating some part of the script is broken. From the errors they describe, it sounds like the problem is related to your recent changes. Oh, you could look at the code you updated to see if you can spot the bug. But more tickets are pouring in and you want to fix the problem as fast as possible. You decided it's time for a rollback"

"git revert HEAD": a new commit is created with inverse changes. This cancels previous changes instead of making it as though the original commit never happened.

"git revert 8d5a3189b88d273ef08286e5074b5e38d616da21": to revert to the earlier version of code.

******************Identifying a Commit*****************
The commit ID is the 40 character long string after the word commit.
This long jumble of letters and numbers is actually something called a hash, which is calculated using an algorithm called SHA1. Essentially, what this algorithm does is take a bunch of data as input and produce a 40 character string from the data as the output. In the case of Git, the input is all information related to the commit, and the 40 character string is the commit ID. 

---------Which of the following is NOT true about the SHA1 hash numbers that Git uses to identify commits?
------------
     Git can identify a commit using the first few hash numbers as long as there is only one matching possibility.

There are some interesting considerations about how git object data is stored, such as the usage of sha-1. 

Feel free to read more here:
-https://en.wikipedia.org/wiki/SHA-1
-https://github.blog/2017-03-20-sha-1-collision-detection-on-github-com/

---------test---------
Question 3
What does Git use cryptographic hash keys for? //
To guarantee the consistency of our repository

*******************What is a branch?******************
So what is a branch? What is it used for? 
In Git, a branch at the most basic level is just a pointer to a particular commit. But more importantly, it represents an independent line of development in a project. Of which the commit it points to is the latest link in a chain of developing history. The default branch that Git creates for you when a new repository initialized is called master. 

-----------What is the purpose of organizing repositories into branches?---------
    By creating a new branch, we can experiment without breaking what already works.

*******************Creating New Branches*************
 We can use the git branch command to list, create, delete, and manipulate branches.

 -"git branch branchName": to create a new branch
 -"git checkout branchName": to switch to another branch
 -"git checkout -b event-better-feature": git create a new branch call "event-better-feature" and switch to it.

 ***********Working with Branches********************
 ------How does git checkout switch branches?--------
    By updating the working tree to match the selected branch.

-"git branch -d branchName": to delete branch we don't need to
-"git branch -D <name>": Forcily deletes the branch


*********************Merging*********************
Merging is the term that Git uses for combining branch data and history together. We'll use the git merge command, which lets us take the independent snapshots and history of one Git branch, and tangle them into another.

-------------What happens when we merge two branches?-----
    Both branches are pointed at the same commit.

Git uses two different algorithms to perform a merge, fast-forward and three-way merge. 
The merge we just performed is an example of a fast-forward merge. This kind of merge occurs when all the commits in the checked out branch are also in the branch that's being merged. If this is the case, we can say that the commit history of both branches doesn't diverge. 

-"git merge branchName": to merge the commit we had done by be on the branch we want to add on


*************Merge Conflicts**************
--------What's the advantage of Git throwing a merge conflict error in cases of overlap?-----
     If two lines have differences Git is unsure about, it's best we decide than risk losing work forever.

-"git log --graph --oneline":display a summarized view of the commit history for a repo, showing one line per commit

-"git merge --abort" : This will stop the merge and reset the files in your working tree back to the previous commit before the merge ever happened.

----Question 1
When we merge two branches, one of two algorithms is used. If the branches have diverged, which algorithm is used?-----
    three-way merge

********************************************************

                        Third part :)        

********************************************************

*******************Working with Remotes*****************
We'll first talk about what GitHub is and why it matters, and then we'll dive into how to work with GitHub and other remote repositories. Being able to use remote repositories allows us to effectively collaborate with others. Our collaborators can be sitting in the same office as we are or they can be thousands of miles away on a different continent working at a different time of day. Using a version control system like Git lets us incorporate the work of different people no matter where they are or when they're working. 

*********************What is GItHub*********************
Git is a distributed version control system. 

Distributed means that each developer has a copy of the whole repository on their local machine.

GitHub is a web-based Git repository hosting service. On top of the version control functionality of Git, GitHub includes extra features like bug tracking, wikis, and task management. 
Other services that provide similar functionality are BitBucket, and GitLab.

---------------Which best describe Github?-------------
GitHub provides free access to a Git server for public and private repositories.

***************Basic Interaction with gittHub*************
-create respository (eg: Health-checks)
-clone respository : git clone
    rg: git clone "link of the remote respo"
    NB: .md: means markdown
-push it on the remote respository: 
    git push

-------After making changes to our local repository, how do we update the remote repository to reflect our changes?----------
    The "git push" command gathers all the snapshots we've taken and sends them to the remote repository.

You've probably noticed that we had to enter our password both when retrieving the repo and when pushing changes to the repo. 
There are a couple ways to avoid having to do this. 
One way is to create:
    -an "SSH key pair" and store the public key in our profile so that GitHub recognizes our computer. 
    -use a "credential helper" which caches our credentials for a time window so that we don't need to enter our password with every interaction. 

Git already comes with a credential helper baked in. We just need to enable it. 
We do that by calling: 
    git config --global credential.helper cache


This can be useful for keeping your local workspace up to date.
    -https://help.github.com/en/articles/caching-your-github-password-in-git
    -https://help.github.com/en/articles/generating-an-ssh-key  

***************What is a remote?*************
-------What will happen if the master repository receives a major update since the last local copy was synced?----
    If there are pending changes in the master branch, Git will let you know.

HTTP is generally used to allow read only access to a repository.
In other words, it lets people clone the contents of your repo without letting them push new contents to it. Conversely HTTPS and SSH, both provide methods of authenticating users so you can control who gets permission to push.

****************Working with Remotes**************
git remote -v: to look at the configuration for that remote respository.

in some cases, you can have the fetch URL use HTTP for read only access, and the push URL use HTTPS or SSH for access control.

Remote repositories have a name assigned to them, by default, the assigned name is "origin". This lets us track more than one remote in the same Git directory.

"git remote show origin": to get even more information about our remote respository

"git branch -r": To  have a look at the remote branches that our Git repo is currently tracking 

-----If we want to make a change to a remote branch, what must we do?-------
    We still have to go through the normal workflow to change remote branches.

***************Fetching New Changes***************
 Git doesn't keep remote and local branches in sync automatically, it waits until we execute commands to move data around when we're ready. 

"git fetch": (Synced data) This command copies the commits done in the remote repository to the remote branches, so we can see what other people have committed.

------What’s the main difference between git fetch and git pull?--------
    git fetch fetches remote updates but doesn't merge; git pull fetches remote updates and merges.

*************Updating the Local Repository************
--------Assuming no merge conflicts, which type of merge does git pull perform automatically?----------
    As long as there are no conflicts, Git will move the current branch tip up to the target branch tip and combine histories of both commits.

"git remote update": to get the contents of remote branches without automatically merging any contents into the local branches

***************The Pull-Merge-Push Workflow***********
If we make change locally on some files it means it will go to unstage files then you commit it but what we have to do after the commit is to update your local project with the remote work because changes can be made there by another person you're working with and finally you'll "push" your local projec to merge it.

------What should you do with the <<<<<<<, =======, and >>>>>>> conflict markers when resolving a merge conflict?----
        
Remove all of the conflict markers and only leave the code as it should be after the merge. because  Conflict markers aren’t required when resolving a merge conflict.

*************Pushing Remote Branches**************
------How do you switch to a new local branch?-------
    git checkout -b <branch name>
     The command git checkout -b <branch name> will first create a new branch and then switch to it.


*************Rebasing Your Changes***************
we mentioned that once our branch has been properly reviewed and tested, it can get merged back into the master branch. This can be done by us or by someone else. One option is to use the git merge command that we discussed earlier. Another option is to use the git rebase command

Rebasing means changing the base commit that's used for our branch. 

 when we create a branch at a certain point in the repo's history, Git knows the latest commit that was submitted on both branches. If only one of the branches has new changes when we try to merge them, Git will be able to fast forward and apply the changes. But if both branches have new changes when we try to merge, Git will create a new merge commit for the three way merge.

 The problem with three way merges is that because of the split history, it's hard for us to debug when an issue is found in our code, and we need to understand where the problem was introduced. By changing the base where our commits split from the branch history, we can replay the new commits on top of the new base. This allows Git to do a fast forward merge and keep history linear.

 ----------What does “git rebase refactor” do?---------
    Move the current branch on top of the refactor branch
     This makes debugging easier and prevents three-way merges by transferring the completed work from one branch to another.
     

**************Another Rebasing Example*****************
git pull: will automatically create a three-way merge

git fetch will put the latest changes into the origin slash master branch but we won't apply them to our local master branch.

We see that we fetched some new changes. This means that if we tried to merge our changes, we end up with a three-way merge. Instead, we'll now run git rebase against our origin/master to rebase our changes against those made by our colleague and keep history linear.

--------Generally, git rebase is an alternative to which command?-------
   " Rebasing instead of merging rewrites history and maintains linearity, making for cleaner code. "

*********Best Practices for Collaboration***********
-It's a good idea to always synchronize your branches before starting any work on your own.

-Avoid having very large changes that modify a lot of different things.
 For example, if you are renaming a variable for clarity reasons, you don't want to have code that adds new functionality in the same commit. It's better if you split it into different commit. This makes it easier to understand what's going on with each commit.

-When working on a big change, it makes sense to have a separate feature branch.

-If you need to maintain more than one version of a project at the same time, it's common practice to have the latest version of the project in the "master branch" and a stable version of the project on a "separate branch".

-You shouldn't rebase changes that have been pushed to remote repos.

---------Which of the following statements is true regarding best practices for collaboration?-------
     This way, when you start changing code, you're starting from the most recent version, minimizing chances of conflicts or the need for rebasing.

-Having good commit messages is important.

NB: important links
    https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/resolving-a-merge-conflict-using-the-command-line

    You can also use git rebase branchname to change the base of the current branch to be branchname

********************************************************

                        fourth part :)        

********************************************************

***********Intro to Module 4: Collaboration***********
If you're trying to learn a new technology, it's a great idea to practice your skills by contributing to a project that uses that technology.
To do that, you'll need to know how to interact with the project. This includes how to send bug fixes, how to make sure that your fixes are applied, and even how to figure out which fixes are needed.

*******A Simple Pull Request on GitHub*********

