An algorithm is a set of well-defined instructions to solve a particular problem. 

************Time and space complexity***********
The absolute running time of an algorithm depends on a number of factors as:
-Programming language used to implement the algorithm
-The computer the program runs on
-Other programs running at the same time
-Quality of the operating system

we evaluate the performance of an algorithm in terms of its input size:
-Time complexity: Amount of time taken by an algorithm to run as a function of input size
-Space complexity: Amount of memory taken by an algorithm to run as a function of input size

 How to represent complexity?
-Mathematical tools to represent time and space complexity
	1. Big-O notation (O notation) Worst case complexity
	2. Omega notation (OMEGA NOTATION) best case complexity
	3. Theta notation (theta notation) Average complexity

In practical we are concern by the worst case complexity of the algorithm.

*******************Big O notation********************
The big-O notation describes the complexity of an algorithm using algebric items. 

It has two characteristics:
	-it is expressed in terms of the input
	- it focuses on the bigger picture without getting caught up in the minute details 

function summation(n) {
	let sum = 0;	---> o(1)
	for (let i = 1; i <= n; i++){
		sum += i;		---> o(n)
	}
	return sum;		---> o(1)
} 
The Big-O notation here is equal to 4+2 or n+2 
Finally is equal to O(n) which is equal to O(n)= linear 

function summation(n) {
	return (n*(n+1))/2;     ---> o(1)
}
This complexity is equal to O(1) which is constant

for (let i = 1; i <= n; i++){
	for (let j = 1; j <= n; j++){

	}
}
Here the time complexity is quadratic O(n^2)

for (let i = 1; i <= n; i++){
	for (let j = 1; j <= n; j++){
		for (let k = 1; k <= n; k++){

		}

	}
}
Here the time complexity is cubic O(n^3)

Space complexity 

*****************Objeccts Big-O**********************
An objects is a collection of key values pairs

	In this example: 

		Const person = {
			firstName: 'BRUCE',
			lastName = 'Wayne'
		}

Insert = O(1)
Remove = O(1)
Access = O(1)
Search = O(n)
object.keys() = O(n)
Objects.values() = O(n)
Objects.entries() = O(n)  


*******************Array big-o***********************
Array is an ordered collections of values:

	const odd = [1,3,5,7,9]

Insert/remove at end = O(1)
Insert/remove at beginnig = O(n) because the index have to be reset for every element of the array.
Access = O(1)
Search = O(n)
push/pop = O(1)
shift /unshift/ concat/ slice/ splice = O(n)
forEach/ map/ filter/ reduce = O(n)

**********************Math algorithm*******************
*************Fibonacci sequence**********
Problem: Given a number 'n', find the first 'n' elements of the Fibonacci sequence.

///Look the fibonacci program