An algorithm is a set of well-defined instructions to solve a particular problem. 

************Time and space complexity***********
The absolute running time of an algorithm depends on a number of factors as:
-Programming language used to implement the algorithm
-The computer the program runs on
-Other programs running at the same time
-Quality of the operating system

we evaluate the performance of an algorithm in terms of its input size:
-Time complexity: Amount of time taken by an algorithm to run as a function of input size
-Space complexity: Amount of memory taken by an algorithm to run as a function of input size

 How to represent complexity?
-Mathematical tools to represent time and space complexity
	1. Big-O notation (O notation) Worst case complexity
	2. Omega notation (OMEGA NOTATION) best case complexity
	3. Theta notation (theta notation) Average complexity

In practical we are concern by the worst case complexity of the algorithm.

*******************Big O notation********************
The big-O notation describes the complexity of an algorithm using algebric items. 

It has two characteristics:
	-it is expressed in terms of the input
	- it focuses on the bigger picture without getting caught up in the minute details 

function summation(n) {
	let sum = 0;	---> o(1)
	for (let i = 1; i <= n; i++){
		sum += i;		---> o(n)
	}
	return sum;		---> o(1)
} 
The Big-O notation here is equal to 4+2 or n+2 
Finally is equal to O(n) which is equal to O(n)= linear 

function summation(n) {
	return (n*(n+1))/2;     ---> o(1)
}
This complexity is equal to O(1) which is constant

for (let i = 1; i <= n; i++){
	for (let j = 1; j <= n; j++){

	}
}
Here the time complexity is quadratic O(n^2)

for (let i = 1; i <= n; i++){
	for (let j = 1; j <= n; j++){
		for (let k = 1; k <= n; k++){

		}

	}
}
Here the time complexity is cubic O(n^3)

Space complexity 

*****************Objeccts Big-O**********************
An objects is a collection of key values pairs

	In this example: 

		Const person = {
			firstName: 'BRUCE',
			lastName = 'Wayne'
		}

Insert = O(1)
Remove = O(1)
Access = O(1)
Search = O(n)
object.keys() = O(n)
Objects.values() = O(n)
Objects.entries() = O(n)  


*******************Array big-o***********************
Array is an ordered collections of values:

	const odd = [1,3,5,7,9]

Insert/remove at end = O(1)
Insert/remove at beginnig = O(n) because the index have to be reset for every element of the array.
Access = O(1)
Search = O(n)
push/pop = O(1)
shift /unshift/ concat/ slice/ splice = O(n)
forEach/ map/ filter/ reduce = O(n)

**********************Math algorithm*******************
*************Fibonacci sequence**********
Problem: Given a number 'n', find the first 'n' elements of the Fibonacci sequence.

///Look the fibonacci program

*****************Factorial of a number*******************
Problem: Give an integer number 'n', find the factorial of that integer

For the basic case 
fact (0) = 1 
fact(4) = 4*3*2*1 = 24

///Look for the function factorial

*****************Prime bumber*************************
Problem: Give a natural number 'n' determine if the number is prime or not

A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers
eg: is prime(5) = true(1*5 or 5*1)
	is prime(4) = false(1*4 or 2*2 or 4*1)

********************Power of two*********************
 Problem: Give a positive integer 'n', determine if the number is a power of 2 or not

 An integer is a power of two if there exists an integer 'x' such that 'n'===2 


******************Recursion******************
What is recursion?
Recursion is a problem solving technique where a function is calls itself

Why do we need it?
A great technique to simplify your solution

Few points about recursive problem:
	-Recursive solution needs to have a base case, a condition to terminate the recursion
	-Recursion might simplify solving a problem but it doesn't always translate to a faster solution 
	-Recursive solution may be far worse compared to an iterative solution
	-Recursion is a topic that is not the most straight foward to understand

*****************Recursive Fibonacci*****************
Problem: Given a number 'n', find the first 'n' elements of the Fibonacci sequence.

****************Linear search*************
A linear search is the simplest approach employed to search for an element in a data set.
Problem: Given an array of 'n' elements and target element 't', find the indice of 't' in the array return -1 if the target of the element is not found.
eg: [-5,2,10,4,6] ,t=10 should return 2  
	[-5,2,10,4,6] ,t=6 should return 4

****************Binary search algorithm**************
Binary search, also known as half-interval search,[1] logarithmic search,[2] or binary chop,
[3] is a search algorithm that finds the position of a target value within a sorted array.
[4][5] Binary search compares the target value to the middle element of the array. If they are not equal, 
the half in which the target cannot lie is eliminated and the search continues on the remaining half, again taking the middle element to compare to the target value,
and repeating this until the target value is found. If the search ends with the remaining half being empty, the target is not in the array.

Problem: Given a sorted array of 'n' elements and target element 't', find the indice of 't' in the array return -1 if the target of the element is not found.
nb: Binary search only works on sorted array 
eg: [-5,2,4,6,10] ,t=10 should return 4.

******************Sorting Algorithm******************
Bubble sort
Insertion sort
Quick sort
Merge sort

******************Bubble sort************************
Problem:Given an array of integers sort the array
Const arr = [-6, 20, 8, -2, 4]
Bubble sort (arr) => [-6, -2, 4, 8, 20]

Principle: 	-In bubble sort algorithm we compare adjacent elements in the array and swap the positions if they are not in the intended order
			-Repeat the instruction as you step throught each element in the array
			-Once you step through the whole array with no swaps, the array is sorted

Eg:[-6 20 8 -2 4]
[-6 20 8 -2 4] -> [-6 8 20 -2 4] swap since 20 > 8
[-6 8 20 -2 4] -> [-6 8 -2 20 4] swap since 20 > -2
[-6 8 -2 20 4] -> [-6 8 -2 4 20] swap since 20 > 4
End of an array. Elements Swapped?Yes?Repeat the comparison
[-6 8 -2 4 20]
[-6 8 -2 4 20] -> [-6 -2 8 4 20] swap since 8 > -2
[-6 -2 8 4 20] -> [-6 -2 4 8 20] swap since 8 > 4
[-6 -2 4 8 20]
End of an array. Elements Swapped?Yes?Repeat the comparison
[-6 -2 4 8 20] [-6 -2 4 8 20] [-6 -2 4 8 20] [-6 -2 4 8 20]
End of an array. Elements Swapped? No? Array is sorted
 
****************Insertion sort*********************
Problem:Given an array of integers sort the array
Const arr = [-6, 20, 8, -2, 4]
Inserion sort (arr) => [-6, -2, 4, 8, 20]

Principle: 	-Virtually split the array into a sorted and an unsorted part
			-Assume that the first element is already sorted and remaining elements are unsorted
			-Select an unsorted element and compare with all elements in the sorted part
 
 Eg: Consider the array: [-6 20 8 -2 4], NTI:number to insert, SE:
 [-6 20 8 -2 4] NTI:20 | SE:-6 | -6>20? no. Place 20 to the right of -6
 [-6 20 8 -2 4] NTI:8 | SE:20 | 20>8? yes. shift 20 to the right.
 [-6 20 20 -2 4] NTI:8 | SE:-6 | -6>8? no. Place 8 to the right of -6
 [-6 8 20 -2 4] NTI:-2 | SE:8 | 20>-2? yes. shift 20 to the right 
 [-6 8 20 20 4] NTI:-2 | SE:8 | 8>-2? yes. shift 8 to the right
 [-6 8 8 20 4] NTI:-2 | SE:-6 | -6>2? no. Place -2 to the right of -6
 [-6 -2 8 20 4] NTI:4 | SE:20 | 20>4? yes shift 20 to the right
 [-6-2 8 20 20] NTI:20 | SE:-6 | -6>20? no. Place 20 to the right of -6
 [-6 -2 8 8 20] NTI:4 | SE:8 | 8>4? yes. shift 8 to the right
 [-6 -2 8 8 20] NTI:20 | SE:-6 | -2>4? no. Place -4 to the right of -2
 [-6 -2 4 8 20] 	Array is sorted

*********************Quick sort*********************
Problem:Given an array of integers sort the array
Const arr = [-6, 20, 8, -2, 4]

Principle:	.Identify the pivot elemennt in the array
				-Pick first element as pivot
				-Pick last element as pivot(Our approach)
				-Pick a random element as pivot
				-Pick median as pivot 
			.Put everything that's smaller than the pivot into the 'left' array and everything that's greater than the pivot into a 'right' array
			.Repeat the process for the individual 'left' and 'right' arrays till you have an array of length 1 which is sorted by definition
			.Repeadly concatenate the left array, pivot and right array till one sorted array remains

eg: Consider the array: [-6 20 8 -2 4] pivot = 4: the last element
[-6 -2] ['4'] [8 20]  	['nbr']: pivot element at each time
[-6] ['-2'] [ ]		[8] ['20'] [ ]
Merging of sub array
[-6 -2] 	[8 20]
Fusion with the fisrt pivot 
[-6 -2]	[4]	[8 20]
Finally merge:
[-6 -2 4 8 20]

*********************Merge sort**********************
Problem:Given an array of integers sort the array
Const arr = [-6, 20, 8, -2, 4]

Principle:	-Divide the array into sub arrays,each containing only one element(An array with one element is consider sorted)
			-Repeatedly merge the sub arrays to produce new sorted sub arrays until there is only one sub array remaining. That will be sorted array.

eg: Consider the array: [-6 20 8 -2 4]
[-6 20]		[8 -2 4]
[-6] [20]	[8] [-2 4]
[-6] [20]	[8] [-2] [4]
Merge individual sub array into new array by checking if elements are sorted
[-6 20]	[8] [-2 4]
[-6 20]	 [-2 4 8]
[-6 -2 4 8 20]

If we take the case of the second part of the array we will have:
[8 -2 4]
[8] [-2 4] => [] left and right are not empty -2<8
[8] [4] => [-2] left and right are not empty 4<8
[8] [] => [-2 4] Right is empty. Push left array
[ ] [ ] => [-2 4 8] both array are empty and we have the sort array

//problem: After calculating marks of the reporcard of some students your aunt asked you. She also asked you to sort all years of born of those student in order so that she will known the avrage of students who are working hard. 
Those average are intger in disorder, sort it to help your aunt.
 
******************Misc problems*******************
Cartesian product
Climbing staricase
Tower of hanoi

****************Cartesian product*****************
problem: Given two finite non empty sets find thier cartesian product
In matchematics, the cartesian product of two sets A and B, denoted A x B is the set of all ordered pairs(a,b) where a is in A and b is in B 
eg: const A = [1 ,2]
	const B = [3, 4]
	AxB = [[1,3],[1,4],[2,3],[2,4]]

*************Climbing staircase*****************
problem: Given a staircase of 'n' steps, count the number of distinct ways to climb to the top.
You can either climb 1 step or 2 steps at a time

n=1, climbingStaircase(1) =1 | 1
n=2, climbingStaircase(2) =2 | (1,1) and (2)
n=3, climbingStaircase(3) =3 | (1,1,1) (1,2) and (2,1)
n=4, climbingStaircase(4) =5 | (1,1,1,1) (1,1,2) (1,2,1) (2,1,1) and (2,2)
...

Climbing stairacase approach:
-At any given time you can climb either 1 step or 2 steps
-If you have to climb to step 'n', we can only climb from step 'n-1' or 'n-2'
-Calculate the ways we can climb to 'n-1' and 'n-2' steps and add the two 
-ClimbingStaircase(n) = climbingStaircase(n-1) + climbingStaircase(n-2)

******************Tower of HANNOI**************
Problem: Move the entire stack of the puzzle to the last rod 

Rules:
-Only one disk may be moved at each time
-Each move consists of taking the upper disk from one of the stacks and placing it on top of the another stack or an empty rod 
-No disk may be placed on top of a disk that is smaller.

It can be traduce mathematically as:
-shift 'n-1' disk from 'A' to 'B' using 'C' (when required)
-shift last disk from 'A' to 'c'
-shift 'n-1' disk from 'B' to 'C' using 'A' (when required)

*******************Recap******************
Algorithm design techniques: which are the general approach to implement algorithm
	-Brute force: Simple and exhaustive technique that evaluates every possible outcome to find the best solution
		eg: Linear search
	-Greedy approach: Choose the option at the current time, without any consideration for the future 
		eg: Djikstra's ,prim's and kruskal algorithm
	-Divide and conquer: Divide the problem into smaller sub problems. Each sub-problems is then solved and the partial solutions are recombined to determine the overall solution.
		eg: Binary search, Quick sort, Merge sort, Tower of hanoi
	-Dynamic programming: Divide the problem into sub-problems, Break it down into smaller but overlapping sub problems. Store the result and reuse it for the same sub-problems.
	This is called Memorization technique that improves the time complexity of your algorithm.
		eg: Fibonacci numbers and climbing staircase
	-BackTracking: Generate all possible solutions. Check if the solution satisfies all the given constains and only then you proceed with generating subsequence solutions. If the constains are not satisfied, backtrack and go on a different path to find the solution 
		eg: N-queens problem

*******************Introduction************
What is datastructure?
	Datastructure is the way to store and organize data so that it can be used efficiently.

Why learn datastructure?
	-Almost every application we build involves data that is modelled in a certain way
	-To efficiently manage taht data, you need data structure
	-The difference between a function taking a few miliseconds vs few seconds or even minutes comes down to the selection of the right data structure
	-Datastructure help you to solve problems in a more efficient way, both in terms of time and memory
	-Learning about data structures also help you again a more prog=found understanding of things you're already aware of
		eg:	-DOM: tree data structure
			-Broser back and foward: stack data structure
			-OS job scheduling: Queue data structure

*******************Array**************
An array is a data structure that can hold a collection of values
	-Arrays can contain a mix of different data types. You can store strings, booleans, numbers or even objects all in the same array
	-Arrays are resizable. You don't have to declare the size of an array before creating it!
	-Javascript arrays are ZERO-indexed and the insertion order is maintained the the last element is (n-1)
	-Arrays are iterables. They can be used with a for of loop
	
****************Object*****************
An object is an unordered collection of key-value pairs. The key must either be a string symbol data type where as the value can be of any data type.
To retreive a value, you can use the corresponding key. This can be achieved using the dot(.) notation or bracket

An object is not an itarate. You cannot use it with a for loop
	

